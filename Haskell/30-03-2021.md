# Семинар 30.03.2021

## Виды типов

Аналогично тому, как функции принимают на вход значения и возвращают значения, конструкторы типов принимают *типы* в качестве аргументов и возвращают *конкретный тип*. `Maybe` сам по себе типом не является, а `Maybe Int` -- уже конкретный тип. Конструкторы типов `Maybe` и `Either` так же отличаются друг от друга, поскольку `Either` принимает два типа-аргумента. Подобно тому, как можно указать тип функции, можно записать и *вид типа*. В какой-то степени конструкторы типов являются функциями над типами.

Обычная функция имеет определённый тип (например, `fst :: (a, b) -> a`) и работает со значениями, которые вычисляются во время выполнения программы. Конструктор типа имеет определённый вид и работает с типами; применение конструктора типа к конкретным типам происходит во время компиляции.

Типы выражений можно посмотреть в интерпретаторе командой `:t`:
```
ghci> :t 'a'
'a' :: Char
ghci> :t Just 1
Just 1 :: Num a => Maybe a
ghci> :t Right True
Right True :: Either a Bool
ghci> :t lookup
lookup :: Eq a => a -> [(a, b)] -> Maybe b
```

Конкретные типы, т.е. те, значения которых мы можем построить, имеют вид `*`. Для обозначения конструкторов типов используется синтаксис, похожий на объявление функций.  Так, конструктор типа `Maybe` имеет вид `* -> *`, т.е. ему надо передать один тип-аргумент, чтобы он стал полноценным типом, например, `Maybe Int`.  У конструктора типа `Either` два аргумента, поэтому он имеет вид `* -> * -> *`.

Как и функции, конструкторы типов можно частично применять, сработает автоматическое каррирование. Т.е. если конструктор типа имеет вид `* -> * -> *`, и ему передали первый аргумент, то мы получим тип вида `* -> *`, на одну звезду меньше. Пример: `Either String`.

Ни `Maybe`, ни `Either`, ни `Either String` не являются типами, т.к. их вид не `*`, мы не можем построить значение такого типа.

Виды типов можно посмотреть командой `:k`:
```
ghci> :k Int
Int :: *
ghci> :k [[Maybe Bool]]
[[Maybe Bool]] :: *

ghci> :k Maybe
Maybe :: * -> *
ghci> :k Maybe String
Maybe String :: *

ghci> :k Either
Either :: * -> * -> *
ghci> :k Either Char
Either Char :: * -> *
ghci> :k Either Char Bool
Either Char Bool :: *
```

Некорректно пытаться узнать "тип типа" или "вид значения":
```
ghci> :t Maybe
Error
ghci> :k 1
Error
```

Все следующие типы имеют вид `* -> *`:
```haskell
data A a = A a
data B a = B a (B a)
data D a = D
-- A, B, D :: * -> *
```

Рассмотрим тип сложнее:
```haskell
data I f a = I (f a)
```
Здесь тип `(f a)` используется в конструкторе значений, поэтому обозначает какой-то конкретный тип вида `*`. Следовательно, `f` должен быть конструктором типа с одним аргументом, а `a` -- конкретным типом. Получаем:
```
f :: * -> *
a :: *
I :: (* -> *) -> * -> *
```
Аналогично рассмотрим:
```haskell
data J f g a = J (f (g a))
```
Здесь тип `(f (g a))` по тем же соображением имеет вид `*`. У конструктора типа `f` один аргумент, `g a` тоже вида `*`, у `g` один аргумент, поэтому:
```
f :: * -> *
g :: * -> *
a :: *
J :: (* -> *) -> (* -> *) -> * -> *
```

Если убрать скобки вокруг `g a`, то результат уже будет другим:
```haskell
data J f g a = J (f g a)
```
Теперь конструктор типа `f` принимает два аргумента вида `*`, поэтому сам имеет вид `* -> * -> *`, и тогда:
```
f :: * -> * -> *
g :: *
a :: *
J :: (* -> * -> *) -> * -> * -> *
```

Ещё несколько примеров, постарайтесь их осознать:
```haskell
data K a f b = K a
-- K :: * -> * -> * -> *
data M f a = MP a | MF (f (M f a))
-- M :: (* -> *) -> * -> *
data O t m a = O (t m a)
-- O :: O :: (* -> * -> *) -> * -> * -> *
```

## Класс Functor

Рассмотрим несколько типов вида `* -> *`, т.е. у которых конструктор типа принимает ровно один аргумент. Можно сказать, что это такие "контейнеры" для значений типа `a`.

```haskell
data Maybe a = Nothing | Just a

data List a = Nil | Cons a (List a)

data Tree a = Empty | Node a (Tree a) (Tree a)
```

Очень часто может потребоваться пройтись по всей структуре и применить функцию к каждому элементу в ней. Для списка есть функция `map`, а для пользовательских типов данных пришлось бы писать несколько очень похожих друг на друга функций, типы которых отличаются только именем конструктора. Хотелось бы как-то обобщить эту идею и получить полиморфную функцию, где переменная `f` будет обозначать конструктор вида `* -> *`.

```haskell
mapMaybe :: (a -> b) -> Maybe a -> Maybe b
mapList  :: (a -> b) -> List a  -> List b
mapTree  :: (a -> b) -> Tree a  -> Tree b
???      :: (a -> b) -> f a     -> f b
```

Таким образом, нам нужна функция с одним интерфейсом, но разными реализациями для каждого отдельного конструктора. Для этого и нужны классы типов. Класс `Functor` описывает следующую идею: есть каким-то образом структурированные элементы типа `a`, и мы хотим заменить их на элементы типа `b`, используя заданную функцию, но при этом не разрушать и не изменять саму структуру. Методом класса `Functor` является функция `fmap :: Functor f => (a -> b) -> f a -> f b`, которая ровно это и делает.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

У рассмотренных ранее классов типов (`Eq`, `Ord`, `Show` и т.д.) в заголовке указывалась переменная, обозначающая конкретный тип. Для класса `Functor` указывается переменная, обозначающая конструктор типа вида `* -> *` (это можно увидеть из сигнатуры метода `fmap`).

Напишем реализации для наших типов:

```haskell
instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap f (Just x) = Just (f x)

instance Functor List where
  fmap _ Nil = Nil
  fmap f (Cons x xs) = Cons (f x) (fmap f xs)

instance Functor Tree where
  fmap _ Empty = Empty
  fmap f (Node x l r) = Node (f x) (fmap f l) (fmap f r)
```

У `Either` вид `* -> * -> *`, но мы можем зафиксировать первый тип-аргумент и написать следующую реализацию:

```haskell
instance Functor (Either c) where
  fmap :: (a -> b) -> Either c a -> Either c b
  fmap _ (Left x) = Left x -- здесь x имеет тип c, мы не можем применить ф-цию
  fmap f (Right x) = Right (f x)
```

Инфиксный синоним функции `fmap`:

```haskell
(<$>) :: Functor f => (a -> b) -> f a -> f b
ghci> show <$> Just 100
Just "100"
```

Для любопытных:
- [Контравариантные функторы](https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html)
- [Бифункторы](https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Bifunctor.html)

## Расширения компилятора

Компилятор GHC предоставляет целый набор расширений языка (дополнительных возможностей). У каждого расширения есть имя. Включить расширение в интерпретаторе можно, установив нужный флаг командой `:set`:

```
ghci> :set -X<имя>
```

Расширение можно включить для всего модуля с кодом, добавив в самое начало директиву компилятора:

```haskell
{-# LANGUAGE <имя> #-}
```

Если приглядеться к реализациям метода `fmap`, то все они очень похожи между собой. Просматриваются все варианты конструкторов значений у типов-альтернатив. Для построения результата используются те же самые конструкторы (структура не изменяется). Если среди параметров конструктора встречаются значения типа `a`, они заменяются на элементы типа `b` (применяется функция). Если среди параметров находятся те, у которых тип `f a` и для `f` есть `instance Functor`, то вызывается `fmap` для этого типа (это не обязательно тот же самый тип). Эти действия механические и компилятор может сгенерировать такую реализацию, если включить расширение `DeriveFunctor`:

```
ghci> :set -XDeriveFunctor
ghci> data XY a = X a | Y [a] deriving (Show, Functor)
ghci> fmap (+1) (X 2)
X 3
ghci> fmap (+1) (Y [2,4])
Y [3,5]
```

Несколько полезных расширений синтаксиса:
- [`TupleSections`](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#tuplesections)
- [`LambdaCase`](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase)
- [`MultiWayIf`](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#multiwayif)
- [`OverloadedLists`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/overloaded_lists.html?highlight=overloadedlists#overloaded-lists)
- [`RecordWildCards`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/record_wildcards.html#record-wildcards)
